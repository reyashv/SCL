import numpy as np

def f(x, y):
    return (2 * x * y) / (1 + x**2)

x0 = 0
y0 = 0
h = 0.1
h_other = 0.1
x_target = 0.4

num_steps_euler = int((x_target - x0) / h)
num_steps_other = int((x_target - x0) / h_other)

x_values_euler = [x0]
y_values_euler = [y0]

for _ in range(num_steps_euler):
    x0 += h
    y0 = y0 + h * f(x0, y0)
    x_values_euler.append(x0)
    y_values_euler.append(y0)

def milne_predictor_corrector(x_values, y_values, h):
    n = len(x_values)
    y_predicted = y_values[n - 1] + (4 * h / 3) * (
        2 * f(x_values[n - 1], y_values[n - 1]) -
        f(x_values[n - 2], y_values[n - 2]) +
        2 * f(x_values[n - 3], y_values[n - 3])
    )
    return y_predicted

def adams_bashforth(x_values, y_values, h):
    n = len(x_values)
    y_predicted = y_values[n - 1] + (h / 24) * (
        55 * f(x_values[n - 1], y_values[n - 1]) -
        59 * f(x_values[n - 2], y_values[n - 2]) +
        37 * f(x_values[n - 3], y_values[n - 3]) -
        9 * f(x_values[n - 4], y_values[n - 4])
    )
    return y_predicted

x_values_milne = x_values_euler.copy()
y_values_milne = y_values_euler.copy()

while x_values_milne[-1] < x_target:
    x0 = x_values_milne[-1] + h_other
    y0 = milne_predictor_corrector(x_values_milne[-4:], y_values_milne[-4:], h_other)
    x_values_milne.append(x0)
    y_values_milne.append(y0)

x_values_adams = x_values_euler.copy()
y_values_adams = y_values_euler.copy()

while x_values_adams[-1] < x_target:
    x0 = x_values_adams[-1] + h_other
    y0 = adams_bashforth(x_values_adams[-4:], y_values_adams[-4:], h_other)
    x_values_adams.append(x0)
    y_values_adams.append(y0)

print("Values at x = 0.1, 0.2, and 0.3 using Euler's method:")
for x, y in zip([0.1, 0.2, 0.3], [y_values_euler[int(x * 10)] for x in [0.1, 0.2, 0.3]]):
    print(f"x = {x:.1f}, y = {y:.4f}")

print(f"y(0.4) by Milne's Predictor-Corrector: {y_values_milne[-1]:.4f}")
print(f"y(0.4) by Adams-Bashforth: {y_values_adams[-1]:.4f}")






import numpy as np

def f(x, y):
    return (2 - y**2) / (5 * x)

x0 = 4.0
y0 = 1.0
h = 0.1

x_target = 4.4
num_steps = int((x_target - x0) / h)

x_values = [x0]
y_values = [y0]

for _ in range(num_steps):
    k1 = h * f(x0, y0)
    k2 = h * f(x0 + h, y0 + k1)
    y0 = y0 + 0.5 * (k1 + k2)
    x0 += h
    x_values.append(x0)
    y_values.append(y0)

for x in [4.1, 4.2, 4.3]:
    index = int((x - x0) / h)
    print(f"y({x:.1f}) using Modified Euler's method: {y_values[index]:.4f}")

def milne_predictor_corrector(x_values, y_values, h):
    n = len(x_values)
    y_predicted = y_values[n - 1] + (4 * h / 3) * (
        2 * f(x_values[n - 1], y_values[n - 1]) -
        f(x_values[n - 2], y_values[n - 2]) +
        2 * f(x_values[n - 3], y_values[n - 3])
    )
    return y_predicted

while x_values[-1] < 4.4:
    x0 = x_values[-1] + h
    y0 = milne_predictor_corrector(x_values[-4:], y_values[-4:], h)
    x_values.append(x0)
    y_values.append(y0)

print(f"y(4.4) by Milne's Predictor-Corrector: {y_values[-1]:.4f}")

def adams_bashforth(x_values, y_values, h):
    n = len(x_values)
    y_predicted = y_values[n - 1] + (h / 24) * (
        55 * f(x_values[n - 1], y_values[n - 1]) -
        59 * f(x_values[n - 2], y_values[n - 2]) +
        37 * f(x_values[n - 3], y_values[n - 3]) -
        9 * f(x_values[n - 4], y_values[n - 4])
    )
    return y_predicted

while x_values[-1] < 4.4:
    x0 = x_values[-1] + h
    y0 = adams_bashforth(x_values[-4:], y_values[-4:], h)
    x_values.append(x0)
    y_values.append(y0)

print(f"y(4.4) by Adams-Bashforth: {y_values[-1]:.4f}")
